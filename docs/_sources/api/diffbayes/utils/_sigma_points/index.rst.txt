:mod:`diffbayes.utils._sigma_points`
====================================

.. py:module:: diffbayes.utils._sigma_points

.. autoapi-nested-parse::

   Private module; avoid importing from directly.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   diffbayes.utils._sigma_points.SigmaPointStrategy
   diffbayes.utils._sigma_points.MerweSigmaPointStrategy
   diffbayes.utils._sigma_points.JulierSigmaPointStrategy



.. py:class:: SigmaPointStrategy

   Bases: :class:`abc.ABC`

   .. autoapi-inheritance-diagram:: diffbayes.utils._sigma_points.SigmaPointStrategy
      :parts: 1
      :private-bases:

   Strategy to use for computing sigma weights + selecting sigma points.

   .. method:: compute_lambda(self, dim: int) -> float
      :abstractmethod:

      Compute sigma point scaling parameter.

      :param dim: Dimensionality of input vectors.
      :type dim: int

      :returns: *float* -- Lambda scaling parameter.


   .. method:: compute_sigma_weights(self, dim: int) -> Tuple[torch.Tensor, torch.Tensor]
      :abstractmethod:

      Helper for computing sigma weights.

      :param dim: Dimensionality of input vectors.
      :type dim: int

      :returns: *Tuple[torch.Tensor, torch.Tensor]* -- Covariance and mean weights. We expect 1D
                float32 tensors on the CPU.



.. py:class:: MerweSigmaPointStrategy

   Bases: :class:`diffbayes.utils._sigma_points.SigmaPointStrategy`

   .. autoapi-inheritance-diagram:: diffbayes.utils._sigma_points.MerweSigmaPointStrategy
      :parts: 1
      :private-bases:

   Sigma point selection in the style of [2].

   [2] http://www.gatsby.ucl.ac.uk/~byron/nlds/merwe2003a.pdf

   :keyword alpha: Spread parameter. Defaults to ``1e-2``.
   :kwtype alpha: float
   :keyword kappa: Secondary scaling parameter, which is typically set to
                   ``0.0`` or ``3 - dim``. If None, we use ``3 - dim``.
   :kwtype kappa: Optional[float]
   :keyword beta: Extra sigma parameter. Defaults to ``2`` (optimal for Gaussians, as
                  per [1]).
   :kwtype beta: float

   .. attribute:: alpha
      :annotation: :float = 0.01

      

   .. attribute:: beta
      :annotation: :float = 2.0

      

   .. attribute:: kappa
      :annotation: :Optional[float]

      

   .. method:: compute_lambda(self, dim: int) -> float

      Compute sigma point scaling parameter.

      :param dim: Dimensionality of input vectors.
      :type dim: int

      :returns: *float* -- Lambda scaling parameter.


   .. method:: compute_sigma_weights(self, dim: int) -> Tuple[torch.Tensor, torch.Tensor]

      Helper for computing sigma weights.

      :param dim: Dimensionality of input vectors.
      :type dim: int

      :returns: *Tuple[torch.Tensor, torch.Tensor]* -- Covariance and mean weights. We expect 1D
                float32 tensors on the CPU.



.. py:class:: JulierSigmaPointStrategy

   Bases: :class:`diffbayes.utils._sigma_points.SigmaPointStrategy`

   .. autoapi-inheritance-diagram:: diffbayes.utils._sigma_points.JulierSigmaPointStrategy
      :parts: 1
      :private-bases:

   Sigma point selection in this style of [1].

   [1] https://www.cs.unc.edu/~welch/kalman/media/pdf/Julier1997_SPIE_KF.pdf

   :keyword lambd: Spread parameter; sometimes denoted as kappa. If
                   ``None``\ , we use ``3 - dim``.
   :kwtype lambd: Optional[float]

   .. attribute:: lambd
      :annotation: :Optional[float]

      

   .. method:: compute_lambda(self, dim: int) -> float

      Compute sigma point scaling parameter.

      :param dim: Dimensionality of input vectors.
      :type dim: int

      :returns: *float* -- Lambda scaling parameter.


   .. method:: compute_sigma_weights(self, dim: int) -> Tuple[torch.Tensor, torch.Tensor]

      Helper for computing sigma weights.

      :param dim: Dimensionality of input vectors.
      :type dim: int

      :returns: *Tuple[torch.Tensor, torch.Tensor]* -- Covariance and mean weights. We expect 1D
                float32 tensors on the CPU.



