:mod:`diffbayes.filters._virtual_sensor_kalman_filter_mixin`
============================================================

.. py:module:: diffbayes.filters._virtual_sensor_kalman_filter_mixin

.. autoapi-nested-parse::

   Private module; avoid importing from directly.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   diffbayes.filters._virtual_sensor_kalman_filter_mixin._IdentityMeasurementModel
   diffbayes.filters._virtual_sensor_kalman_filter_mixin._VirtualSensorKalmanFilterMixin



.. py:class:: _IdentityMeasurementModel(*, state_dim)

   Bases: :class:`diffbayes.base.KalmanFilterMeasurementModel`

   .. autoapi-inheritance-diagram:: diffbayes.filters._virtual_sensor_kalman_filter_mixin._IdentityMeasurementModel
      :parts: 1
      :private-bases:

   Identity measurement model. For use with our virtual sensor Kalman filters, which
   assume that the "observation" of the system is in the state space.

   Possible extension to consider in the future: we could very reasonably have both a
   virtual sensor *and* a measurement model, which each map to a latent space.

   .. attribute:: scale_tril
      :annotation: :types.ScaleTrilTorch

      Lower-triangular uncertainty term, with shape
      ``(N, state_dim, state_dim)``. This should be set externally.

      :type: torch.Tensor


   .. method:: forward(self, *, states: types.StatesTorch) -> Tuple[types.ObservationsNoDictTorch, types.ScaleTrilTorch]

      Observation model forward pass, over batch size ``N``.

      :param states: States to pass to our observation model.
                     Shape should be ``(N, state_dim)``.
      :type states: torch.Tensor

      :returns: *Tuple[torch.Tensor, torch.Tensor]* -- tuple containing expected observations
                and cholesky decomposition of covariance.  Shape should be ``(N, M)``.


   .. method:: jacobian(self, *, states: types.StatesTorch) -> torch.Tensor

      To avoid using autograd for computing our models Jacobian, we can directly
      return identity matrices.

      :param states: Current state, size ``(N, state_dim)``.
      :type states: torch.Tensor

      :returns: *torch.Tensor* -- Jacobian, size ``(N, observation_dim, state_dim)``



.. py:class:: _VirtualSensorKalmanFilterMixin(*, dynamics_model: DynamicsModel, virtual_sensor_model: VirtualSensorModel, **kwargs)

   Bases: :class:`diffbayes.base.KalmanFilterBase`

   .. autoapi-inheritance-diagram:: diffbayes.filters._virtual_sensor_kalman_filter_mixin._VirtualSensorKalmanFilterMixin
      :parts: 1
      :private-bases:

   Base class for a generic Kalman-style filter. Parameterizes beliefs with a mean
   and covariance.

   Subclasses should override _predict_step() and _update_step().

   .. attribute:: virtual_sensor_model
      

      Virtual sensor model.

      :type: diffbayes.base.VirtualSensorModel


   .. method:: _update_step(self, *, observations: types.ObservationsTorch) -> None

      Kalman filter measurement update step.

      Nominally, computes $\mu\ *{t | t}$, $\Sigma*\ {t | t}$ from $\mu\ *{t | t - 1}$,
      $\Sigma*\ {t | t - 1}$.

      Updates ``self.belief_mean`` and ``self.belief_covariance``.

      :keyword observations: Observation inputs.
      :kwtype observations: dict or torch.Tensor


   .. method:: virtual_sensor_initialize_beliefs(self, *, observations: types.ObservationsTorch)

      Use virtual sensor model to intialize filter beliefs.

      :param observations: observation inputs. should be
                           either a dict of tensors or tensor of shape ``(N, ...)``
      :type observations: dict or torch.Tensor



